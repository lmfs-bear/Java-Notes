# 思维体操

## 勇者斗恶龙

[Dragon of Loowater - UVA 11292 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/UVA-11292)

**Description**

> 有n个头的恶龙，你希望雇一些骑士把它杀死（即砍掉所有头）。村里有ｍ个骑士可以雇佣，一个能力值为x的骑士可以砍掉恶龙一个直径不超过x的头，且需要支付x个金币。如何雇佣骑士才能砍掉恶龙的所有头，且需要支付的金币最少？注意，一个骑士只能砍一个头（且不能被雇佣两次）

**思路**：能力强的骑士开价高是合理的，但如果被你派去砍一个很弱的头，就是浪费人才了。因此，可以把雇佣来的骑士按照能力从小到大排序，所有头按照直径从小到大排序，一个一个砍就可以了。当然，不能砍掉“当前需要砍的头”的骑士就不要雇佣了。 

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main {

  /**
   * 快速输入类
   */
  static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
  static StringTokenizer tokenizer = new StringTokenizer("");

  /**
   * 获取下一段文本
   */
  static String next() throws IOException {
    while (!tokenizer.hasMoreTokens()) {
      tokenizer = new StringTokenizer(reader.readLine());
    }
    return tokenizer.nextToken();
  }

  static int nextInt() throws IOException {
    return Integer.parseInt(next());
  }

  static double nextDouble() throws IOException {
    return Double.parseDouble(next());
  }

  public static void main(String[] args) throws IOException {
    while (true) {
      int n = nextInt(), m = nextInt();
      if (n == 0 && m == 0) {
        break;
      }
      int[] dragons = new int[n];
      int[] killers = new int[m];
      for (int i = 0; i < n; i++) {
        dragons[i] = nextInt();
      }
      for (int i = 0; i < m; i++) {
        killers[i] = nextInt();
      }
      Arrays.sort(killers);
      Arrays.sort(dragons);
      int ans = 0;
      int cur = 0;
      for (int i = 0; i < m; i++) {
        if (killers[i] >= dragons[cur]) {
          ans += killers[i];
          if (++cur == n) {  //头已经砍完
            break;
          }
        }
      }
      if (cur < n) {
        System.out.println("Loowater is doomed!");
      } else {
        System.out.println(ans);
      }
    }
  }
}
```

## 突击战

[Commando War - UVA 11729 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/UVA-11729)

**Description**

> 你有 n 个部下， n 个任务，你计划让部下 i 去做任务 i (1<=i< =n ) ，但部下还不知道任务 的内容，需要你为每个部下解释任务内容（即交代任务）。第 i 个部下需要你花 B(i) 分钟交代任务，然后他会立刻、独立地、无间断地执行 J( i) 分钟后完成任务。你每次只能给一个部下交代任务，但部下们可以同时执行各自的任务。

**思路**：直觉告诉我们，执行时间较长的任务应该先交待。于是我们想到这样一个贪心算法:按照J从大到小的顺序给各个任务排序，然后依次交待。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main {

  /**
   * 快速输入类
   */
  static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
  static StringTokenizer tokenizer = new StringTokenizer("");

  /**
   * 获取下一段文本
   */
  static String next() throws IOException {
    while (!tokenizer.hasMoreTokens()) {
      tokenizer = new StringTokenizer(reader.readLine());
    }
    return tokenizer.nextToken();
  }

  static int nextInt() throws IOException {
    return Integer.parseInt(next());
  }

  static double nextDouble() throws IOException {
    return Double.parseDouble(next());
  }

  public static void main(String[] args) throws IOException {
    commando();
  }

  public static void commando() throws IOException {
    int count=0;
    while (true) {
      int n = nextInt();
      if (n == 0) {
        break;
      }
      int[][] data = new int[n][2];
      for (int i = 0; i < n; i++) {
        data[i][0] = nextInt();
        data[i][1] = nextInt();
      }
      Arrays.sort(data, (o1, o2) -> {
        return o2[1] - o1[1];
      });
      int ans = 0;
      int cur = 0;
      for (int i = 0; i < n; i++) {
        cur += data[i][0];
        ans = Math.max(ans, cur + data[i][1]);
      }
      System.out.println("Case "+(++count)+": "+ans);
    }
  }

}

```

## 分金币

[Spreading the Wealth - UVA 11300 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/UVA-11300)

**Description**

> 圆桌旁坐着n个人，每人有一定数量的金币，金币总数能被n整除。每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数目相等。你的任务是求出被转手的金币数量的最小值。比如，n=4，且4个人的金币数量分别为1,2,5,4时，只需转移4枚金币(第3个人给第2个人两枚金币，第2个人和第4个人分别给第1个人1枚金币〉即可实现每人手中的金币数目相等。

**思路**

> 设M表示每人最后拥有的金币数。
> 设xi表示第i个人要给他前面的人的金币数目，如x2表示第二个人要给第一个人的金币数
> （x1指的是1号给最后一个人的金币数）
> 对于第1个人，A1-x1+x2=M→x2=M-A1+x1=x1- (A1 - M)
> 对于第2个人，A2-x2+x3=M→x3=M-A2+x2=2M-A1-A2+x1=x1- (A2 - M) - (A1 - M)
> 对于第3个人，A3-x3+x4-M→x4=M-A3+x3=3M-A1-A2-A3+x1=x1- (A3 - M) - (A2 - M) - (A1 - M)
> …
> 规定C1=A1-M, 则
> x1 = x1 - C1
> x2 = x1 - (A2 - M) - C1 = x1 - C2
> …
> 我们可以得出 ：C[i] = C[i-1] + A[i] - M;
> 我们希望所有xi的绝对值之和尽量小，即Ix1l+lx1-C1l+lx2-C2|+…+lx1-Cn|要最小。注意到|x1-Cl的几何意义是数轴上点x到C的距离，所以问题变成了：给定数轴上的n个点，找出一个到它们的距离之和尽量小的点。这个最优的x1就是这些数的“中位数”
> 中位数代入即可求值
> （《算法竞赛入门经典——训练指南》/刘汝佳，陈锋编著. P5-P6）

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {


  public static void main(String[] args) {
    wealth();
  }

  public static void wealth() {
    Scanner scanner = new Scanner(System.in);
    while (scanner.hasNext()) {
      int n = scanner.nextInt();
      if (n == 0) {
        System.out.println(0);
        continue;
      }
      long[] a = new long[n];
      long[] c = new long[n];
      long sum = 0;
      for (int i = 0; i < n; i++) {
        a[i] = scanner.nextLong();
        sum += a[i];
      }
      long M = sum / n;
      c[0] = a[0] - M;
      for (int i = 1; i < n; i++) {
        c[i] = c[i - 1] + a[i] - M;
      }
      Arrays.sort(c);
      int k = n / 2;
      long mid = c[k];
      if (n % 2 == 0) {
        mid = (mid + c[k - 1]) / 2l;
      }
      long ans = 0;
      for (int i = 0; i < n; i++) {
        ans += Math.abs(mid - c[i]);
      }
      System.out.println(ans);
    }
  }

}

```

## 墓地雕塑

[Graveyard - UVALive 3708 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/UVALive-3708)

**Description**

> 在一个周长为10000的圆上等距分布着n个雕塑。现在又有m个新雕塑加入（位置可以随意放)，希望所有n+m个雕塑在圆周上均匀分布。这就需要移动其中一些原有的雕塑。要求n个雕塑移动的总距离尽量小。

```java
public static void graveyard() {
  Scanner scanner = new Scanner(System.in);
  while (scanner.hasNext()) {
    int n = scanner.nextInt(), m = scanner.nextInt();
    double ans = 0.0;
    for (int i = 1; i < n; i++) {
      double pos = (double) i / n * (n + m);  //计算每个需要移动的雕塑的坐标
      ans += Math.abs(pos - (int) (pos + 0.5)) / (n + m);
    }
    ans *= 10000;
    System.out.println(String.format("%.4f", ans));
  }
}
```

## 蚂蚁

**Description**

> Piotr likes playing with ants. He has n of them on a horizontal pole L cm long. Each ant is facing
> either left or right and walks at a constant speed of 1 cm/s. When two ants bump into each other, they
> both turn around (instantaneously) and start walking in opposite directions. Piotr knows where each
> of the ants starts and which direction it is facing and wants to calculate where the ants will end up T
> seconds from now.

**思路**：掉头等于“对穿而过” , 但蚂蚁的相对顺序是不变的(脑补)。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

  /**
   * 快速输入类
   */
  static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
  static StringTokenizer tokenizer = new StringTokenizer("");

  /**
   * 获取下一段文本
   */
  static String next() throws IOException {
    while (!tokenizer.hasMoreTokens()) {
      tokenizer = new StringTokenizer(reader.readLine());
    }
    return tokenizer.nextToken();
  }

  static int nextInt() throws IOException {
    return Integer.parseInt(next());
  }

  static double nextDouble() throws IOException {
    return Double.parseDouble(next());
  }

  public static void main(String[] args) throws IOException {
    Main main = new Main();
    main.ants();
  }

  class Ant {

    int id;
    int p;
    int d;  //-1左 1右 0碰撞中

    public Ant(int id, int p, int d) {
      this.id = id;
      this.p = p;
      this.d = d;
    }
  }

  public void ants() throws IOException {
    int num = nextInt();
    for (int i = 0; i < num; i++) {
      int L = nextInt(), T = nextInt();
      int n = nextInt();
      Ant[] ants = new Ant[n];
      Ant[] after = new Ant[n];
      for (int j = 0; j < n; j++) {
        int p = nextInt();
        char d = next().charAt(0);
        ants[j] = new Ant(j, p, d == 'L' ? -1 : 1);
        after[j] = new Ant(0, p, d == 'L' ? -1 : 1);
        if (d == 'L') {
          after[j].p = p - T;
        } else {
          after[j].p = p + T;
        }
      }
      Arrays.sort(ants, (o1, o2) -> {
        return o1.p - o2.p;
      });
      Arrays.sort(after, (o1, o2) -> {
        return o1.p - o2.p;
      });
      for (int j = 0; j < n; j++) {
        after[j].id = ants[j].id;
      }
      for (int j = 0; j < n - 1; j++) {
        if (after[j].p == after[j + 1].p) {
          after[j].d = after[j + 1].d = 0;
        }
      }
      Arrays.sort(after, (o1, o2) -> {
        return o1.id - o2.id;
      });
      System.out.println("Case #" + (i + 1) + ":");
      for (int j = 0; j < n; j++) {
        if (after[j].p < 0 || after[j].p > L) {
          System.out.println("Fell off");
        } else {
          System.out.println(
              after[j].p + " " + (after[j].d == 0 ? "Turning" : (after[j].d == -1 ? "L" : "R")));
        }
      }
      System.out.println("");
    }
  }

}

```



